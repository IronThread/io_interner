//! A simple crate implementing a struct wrapping a reader and writer that's used to create readers
//! to unique data.

use ::std::{
    hash::{Hash, Hasher},
    io::{self, prelude::*, SeekFrom},
    ptr,
    sync::Mutex,
};

/// A struct generated by [`IOEntry::get_object`].
pub struct IOObj<'a, T> {
    start_init: u64,
    start: u64,
    len: u64,
    guard: &'a Mutex<T>,
}

/// A struct generated by [`IOInterner::get_or_intern`].
pub struct IOEntry<'a, T> {
    start_init: u64,
    len: u64,
    guard: &'a Mutex<T>,
}

impl<'a, T> IOEntry<'a, T> {
    /// Creates a new [`IOObj`] that can be [`Read`] and [`Seek`] but cannot be test for
    /// [`eq`][`PartialEq::eq`]uality nor [`hash`][`Hash`]ed because of the seeking operations that
    /// end up changing the data it points.
    pub fn get_object(&self) -> IOObj<'a, T> {
        IOObj {
            start: self.start_init,
            start_init: self.start_init,
            len: self.len,
            guard: self.guard
        }
    }
}

impl<'a, T> PartialEq for IOEntry<'a, T> {
    fn eq(&self, other: &Self) -> bool {
        self.start_init == other.start_init && self.len == other.len && ptr::eq(self.guard, other.guard)
    }
}

impl<'a, T> Eq for IOEntry<'a, T> {}

impl<'a, T> Hash for IOEntry<'a, T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.start_init.hash(state);
        self.len.hash(state);
        ptr::hash(self.guard, state)
    }
}

impl<'a, T> Clone for IOEntry<'a, T> {
    fn clone(&self) -> Self {
        unsafe { ptr::read(self) }
    }
}

impl<'a, T> Clone for IOObj<'a, T> {
    fn clone(&self) -> Self {
        unsafe { ptr::read(self) }
    }
}

impl<'a, T: Read + Seek> Read for IOObj<'a, T> {
    /// Invokes `Read::read` in the underlying reader seeking to the position this entry starts
    /// and only taking as much bytes as the length of this entry.
    #[inline]
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        if self.len == 0 {
            return Ok(0);
        }

        let mut l = self.guard.lock().unwrap();
        l.seek(SeekFrom::Start(self.start))?;

        let len = <&mut T as Read>::take(&mut *l, self.len).read(buf)?;
        self.seek(SeekFrom::Current(len as _))?;
        Ok(len)
    }
}

impl<'a, T> Seek for IOObj<'a, T> {
    #[inline]
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        match pos {
            SeekFrom::Current(x) => {
                if x.is_negative() {
                    let x = x.abs() as u64;
                    let new_start = self.start.saturating_sub(x);

                    if new_start < self.start_init {
                        return Err(io::ErrorKind::InvalidInput.into());
                    }

                    self.start = new_start;
                    self.len += x;
                } else {
                    let x = x.abs() as u64;

                    if x > self.len {
                        self.start += self.len;
                        self.len = 0;
                    } else {
                        self.start += x;
                        self.len -= x;
                    }
                }
                Ok(self.start - self.start_init)
            }
            SeekFrom::Start(x) => {
                let new_start = self.start_init + x;

                if new_start > self.start {
                    self.seek(SeekFrom::Current((new_start - self.start) as i64))
                } else {
                    self.seek(SeekFrom::Current(-((self.start - new_start) as i64)))
                }
            }
            SeekFrom::End(x) => {
                self.start += self.len;
                self.len = 0;

                self.seek(SeekFrom::Current(x))
            }
        }
    }
}

/// A struct wrapping a `Mutex<T>` used for storing and retrieving data thought readers.
///
/// Note that `T` it's wrapped into a [`Mutex`] for ensure [`IOObj`] does not lock access to the
/// `IOInterner` and to guarantee will only lock at `Read` methods.
pub struct IOInterner<T: Write + Read + Seek> {
    /// The underlying writer wrapped into a `Mutex`.
    ///
    /// The [`IOEntry`] comparison algorithm would mess up if you do not ensure that already
    /// allocated data remain equal after releasing a lock,it's advisable to only write at the end.
    pub inner: Mutex<T>
}

impl<T: Write + Read + Seek> IOInterner<T> {
    /// Create a new `IOInterner` that uses as common storage `x`.
    #[inline]
    pub fn new(x: T) -> Self {
        Self { inner: Mutex::new(x) }
    }

    /// Invokes [`Write::flush`] on `self.inner`.
    ///
    /// # Panics
    ///
    /// This function panics if the [`Mutex`] it's poisoned.
    #[inline]
    pub fn flush(&self) -> io::Result<()> {
        self.inner.lock().unwrap().flush()
    }

    /// Creates a new `IOEntry` object that will be able to generate [`IOObj`] that always read
    /// same bytes as `buf` from `T` so `buf` will be written at the end if it's not already.
    ///
    /// The [`IOObj`] does not implement `Write` as that would mess up equality of two
    /// [`IOEntry`] instances pointing to the same position with same length which it's actually
    /// the comparison algorithm.
    ///
    /// # Panics
    ///
    /// This function panics if the [`Mutex`] it's poisoned.
    pub fn get_or_intern<U: Read + Seek>(&self, mut buf: U) -> io::Result<IOEntry<'_, T>> {
        let mut l = self.inner.lock().unwrap();

        let buf_len = buf.seek(SeekFrom::End(0))?;

        if buf_len == 0 {
            return Ok(IOEntry {
                start_init: 0,
                len: 0,
                guard: &self.inner,
            });
        }

        let len = l.seek(SeekFrom::End(0))?;

        for start in 0..len.saturating_sub(buf_len) {
            l.seek(SeekFrom::Start(start))?;
            buf.seek(SeekFrom::Start(0))?;

            if starts_with(&mut *l, &mut buf)? {
                return Ok(IOEntry {
                    start_init: start,
                    len: buf_len,
                    guard: &self.inner,
                });
            }
        }

        l.seek(SeekFrom::Start(len))?;
        buf.seek(SeekFrom::Start(0))?;
        io::copy(&mut buf, &mut *l)?;
        l.flush()?;

        Ok(IOEntry {
            start_init: len,
            len: buf_len,
            guard: &self.inner,
        })
    }
}

/// Checks if the contents of the reader `x` are the ones of `y`.
///
/// # Errors
///
/// See [`io::copy`].
pub fn eq<R1: Read, R2: Read>(x: R1, y: R2) -> io::Result<bool> {
    io_op(x, y, PartialEq::eq)
}

/// Checks if the first contents of the reader `haystack` are the ones of `needle`,an empty needle
/// is always true.
///
/// # Errors
///
/// See [`io::copy`].
pub fn starts_with<R1: Read, R2: Read>(haystack: R1, needle: R2) -> io::Result<bool> {
    io_op(haystack, needle, <[u8]>::starts_with)
}

fn io_op<R1: Read, R2: Read>(
    mut x: R1,
    mut y: R2,
    callback: impl Fn(&[u8], &[u8]) -> bool,
) -> io::Result<bool> {
    let mut buf1 = [0; 512];
    let mut buf2 = [0; 512];

    Ok(loop {
        let mut buf1r = &mut buf1[..];
        let mut buf2r = &mut buf2[..];

        let mut x = (&mut x).take(buf1r.len() as _);
        let mut y = (&mut y).take(buf1r.len() as _);

        let readed1 = io::copy(&mut x, &mut buf1r)? as usize;
        let readed2 = io::copy(&mut y, &mut buf2r)? as usize;

        if !callback(&buf1[..readed1], &buf2[..readed2]) {
            break false;
        }

        if readed1 == 0 || readed2 == 0 {
            break true;
        }
    })
}
